# **电脑开机的时候系统做了什么**

1.加载BIOS

开机程序在ROM中（只读存储器；有RMOM PROM EPROM 

当计算机通电的时候，首先读取ROM， ROM里面的程序叫做**基本输入输出系统（Basic Input Output System BIOS）**

BIOS首先“硬件自检”，查看硬件是否能够工作；BIOS把权限交给启动程序，用来对启动设备进行排序，依次启动。基本就是对主板上的键盘、鼠标、外部接口、磁盘驱动器等方面进行

2.读取MBR **主引导记录（MBR）**

存储设备最前面的512个字节叫做**主引导记录（MBR）**

3）Bootloader

是在操作系统内核运行之前  运行的一段小程序，可以初始化硬件设备、建立**内存空间的映射图**，为最终调用操作系统内核做好一切准备

4.加载内核

内核加载后，开始**操作系统初始化**，根据进程的优先级启动进程



# 都有那些编程范式

面向过程

面向对象

面向接口

函数式

响应式





# C++和C的区别

**面向过程**就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了.

**性能比面向对象高**，因为类调用时需要实例化，开销比较大，比较消耗资源

比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素



**面向对象**是把构成问题**事物分解成各个对象**，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为

易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护

性能比面向过程低



# C++和java的区别

1.指针：java语言在程序员层面屏蔽了指针，让程序员没办法根据指针找到内存，所以没有指针这一概念

2.数据类型和类：java是一门完全面向对象的语言，因此所有的函数和变量必须是类的一部分，除了基本数据类型之外，其余都是作为类对象而存在的，对象将数据和方法结合起来把其封装在类中

3.操作符重载：java不支持操作符重载，这是c++突出特性之一

5.自动内存管理：java在堆上建立内存无需手动释放，内存回收是用现成的方式在后台运行，利用空闲时间删除



# c++为什么不加入垃圾回收机制

作为支持指针的编程语言，C++将动态管理内存的便利性交给了程序员，在使用指针形式的对象时，程序员必须自己完成存储器的分配、使用和释放，语言本身在此过程中不能提供任何帮助





# 在 4GB 物理内存的机器上，申请 8G 内存 

应用程序通过 malloc 函数申请内存的时候，**实际上申请的是虚拟内存，此时并不会分配物理内存**

1.32还是64

1. `32` 位系统的内核空间占用 `1G`，位于最高处，剩下的 `3G` 是用户空间；进程最多只能申请 3 GB 大小的虚拟内存空间，所以进程申请 8GB 内存的话，在申请虚拟内存阶段就会失败
2. `64` 位系统的内核空间和用户空间都是 `128T`，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的；进程申请 8GB 内存是没问题的，因为进程申请内存是申请虚拟内存，只要不读写这个虚拟内存，操作系统就不会分配物理内存



# CPU 与 GPU 到底有什么区别

**CPU：叫做中央处理器 作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元**

**GPU：叫做图形处理器 是一种专门做图像和图形相关运算工作的微处理器**



- **CPU：计算量小， GPU：计算量大**
- **CPU：可计算复杂的运算  GPU：只可以计算简单重复运算**



GPU专为多任务而生，并发能力强，具体来讲就是多核；

一般的CPU有2核、4核、8核等，而GPU则可能会有成百上千核



## 大数据 `topk` 问题 n个整数，求最大的k个整数

用**最小堆**，首先用前k个数构建一个最小堆，这样堆顶元素是最小的，然后遍历剩下的数，**如果大于堆顶，则用它替换堆顶**，并调整堆，保持最小堆。如果小于或者等于则直接跳过



## hashmap底层

数组+链表

数组+红黑树（链表长度大于8 且数组长度大于64



## go协程

[一文看懂Go语言协程的设计与原理 - 掘金 (juejin.cn)](https://juejin.cn/post/7044741465930465311)

协程作为用户态线程，也是轻量级的线程，**用来解决高并发场景下线程切换的资源开销**

协程跟线程是有区别的

- 线程/进程是内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）
- **协程 对内核是透明的**，也就是系统并不知道有协程的存在，是完全由用户**自己的程序进行调度**，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到

 

**goroutine存在的意义是什么**

1.操作系统线程的创建和切换都需要进入内核，而进入内核所消耗的性能代价比较高，开销较大

2.内核在创建操作系统线程时默认会为其分配一个较大的栈内存，同时会有溢出的风险

**goroutine的优势也就是 开销小**

1.goroutine是用户态线程，其创建和切换都在用户代码中完成而无需进入操作系统内核，所以其开销要远远小于系统线程的创建和切换

2.**goroutine启动时默认栈大小只有2k**，这在多数情况下已经够用了，即使不够用，goroutine的栈也会自动扩大



















