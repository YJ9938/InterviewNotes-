## 0320

**一、RPC 远程程序调用**

RPC在 HTTP之前

PRC主要是用于公司内部 各种微服务间通讯

区别

- 服务发现（找到ip地址和服务端口） HTTP有dns  RPC有专门中间服务去保存信息
- 底层连接形式 都是通过建立TCP长连接进行数据交互， RPC一般有连接池 处理请求量大情况
- 传输内容：HTTP1.1为例 传递内容主要是字符串为主，body使用json序列化数据， RPC定制化程度高，可以使用protobuf，也不用考虑浏览器各种行为，比如重定向之类，性能更好
- 为什么不用HTTP2  时间原因 2015年出来，很多公司就懒得换了



**二、HTTP**

1.HTTP1.1

**一次一个请求响应** （会有HTTP队头阻塞 ）多个HTTP请求都用同一个TCP连接

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

- 使用**长连接**的方式改善了 HTTP/1.0 短连接造成的性能开销 
- 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间 （**可能存在 队头阻塞**

2.HTTP2 (基于 HTTPS 的)

解决HTTP1.1的 **HTTP协议层面 队头阻塞**

- 头部压缩; 同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**
- 二进制格式：**（更加安全）**直接解析二进制报文，这**增加了数据传输的效率**
- 并发传输：**解决 HTTP这一层的队头阻塞** 
- 服务器主动推送资源;

3.HTTP3

解决**TCP层面的队头阻塞**

在UDP上实现QUIC（整合了TLS

- 无队头阻塞 
- 更快的连接建立（将TLS握手次数减少
- 连接迁移（从4g 切到wifi 可以不用重新建立连接



**三、TLS**

 传输层

TLS三次握手

 ![TLS](D:\02实习\02Notes\InterviewNotes\笔记图片\TLS.png)



## 0301

**一、TCP粘包问题**

发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，**后一包数据的头紧接着前一包数据的尾**，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方

原因

- 发送方：收集多个小分组，在一个确认到来时一起发送

- 接收方：TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组

  如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包

如何处理

- 发送方：关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法

- 接收方：只能交给应用层

- 应用层：不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题

  格式化数据：每条数据有固定的格式（开始符，结束符）

  发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置

**UDP是否存在粘包**

UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题



**二、RPC   HTTP**

1. RPC:**远程过程调用**， 本身并不是一个具体的协议，而是一种**调用方式**

目的是希望程序员能像调用本地方法那样去调用远端的服务方法， 同时 RPC 有很多种实现方式，**不一定非得基于 TCP 协议**

2. HTTP:**超文本传输协议**



主要是传输内容有区别：

HTTP内容很冗余，比如Header中信息，Body中的Json 结构等等

RPC定制化程度高，可以用体积更小的协议去保存数据，性能会更好，同时不用考虑像HTTP考虑浏览器的行为，比如重定向之类的



**三、HTTP**

1.状态码

![网络08](D:\02实习\02Notes\InterviewNotes\笔记图片\网络08.png)

2xx

- 200 OK 表示一切正常
- 204 **No Content** 响应头没有 body 数据
- 206 **Partial Content**  表示响应返回的 body 数据并不是资源的全部，而是其中的一部分

3xx  重定向 需要客户端用新的 URL 重新发送请求获取资源

- 301 永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问
- 302 临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问
- 304 表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向， **告诉客户端可以继续使用缓存资源**

4xx 表示客户端发送的**报文有误**，服务器无法处理

- 400 客户端请求的报文有错误 （笼统
- 403  服务器禁止访问资源
- **404**  请求的资源在服务器上不存在或未找到

5xx **服务器处理时内部发生了错误**，属于服务器端的错误码

- 500 笼统通用的错误码，服务器发生了什么错误
- 501 客户端请求的功能还不支持
- **502**  服务器作为网关或代理时返回的错误码， 服务器自身工作正常，访问后端服务器发生了错误
- 503 服务器当前很忙，暂时无法响应客户端



**五、TCP keepalive  和  HTTP Keep-Alive**

HTTP 的 Keep-Alive，是由**应用层（用户态）** 实现的，称为 HTTP 长连接；

- HTTP 的 Keep-Alive 也叫 HTTP 长连接，该功能是由「应用程序」实现的，可以使得用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少了 HTTP 短连接带来的多次 TCP 连接建立和释放的开销

TCP 的 Keepalive，是由 **TCP 层（内核态）** 实现的，称为 TCP 保活机制

- 该功能是由「内核」实现的，当客户端和服务端长达一定时间没有进行数据交互时，内核为了确保该连接是否还有效，就会发送探测报文，来检测对方是否还在线，然后来决定是否要关闭该连接



**6.GET  POST**

GET 从服务器获取资源，请求参数写在URL中 只允许ASCII字符，且浏览器对URL长度有限制

POST 根据请求负荷（报文body） 对指定资源做出处理， 请求携带数据的位置一般是写在报文 body 中，body 中的数据可以是任意格式的数据， 浏览器不会对 body 大小做限制



「幂等」，意思是多次执行相同的操作，结果都是「相同」的

- **GET 方法就是安全且幂等的**，因为它是「只读」操作
- **POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的

但是实际过程中，开发者不一定会按照 RFC 规范定义的语义来实现 GET 和 POST 方法

- 可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等 
- 可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等



**7.HTTPS一定安全吗**

中间人攻击 ： 从客户端的角度看，其实并不知道网络中存在中间人服务器这个角色；那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据

中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，而**这个伪造的证书是能被浏览器（客户端）识别出是非法的**，于是就会提醒用户该证书存在问题

**HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全 **





## 0228

**一、用来tcp协议 数据一点不会丢吗**

1.丢包情况

- 建立连接时丢包：建立连接时服务端有 **半连接队列、全连接队列** 如果它们**满了**，那新来的包就会被**丢弃**
- 流量控制丢包： 当发送数据过快，流控队列长度`txqueuelen`又不够大时，就容易出现**丢包**现象
- 网卡丢包：网卡和它的驱动导致丢包的场景，原因很多，比如**网线质量差，接触不良**
- 接收缓冲区丢包：一般使用`TCP socket`进行网络编程的时候，内核都会分配一个**发送缓冲区**和一个**接收缓冲区**
- 两端之间的网络丢包：两端之间那么长的一条链路都属于外部网络，这中间有各种路由器和交换机还有光缆啥的，丢包也是很经常发生的



2.发生丢包怎么办

使用TCP协议去传输：如果中间链路发生了丢包，那发送端会迟迟收不到确认ack，于是就会进行**重传**； 以此来保证每个数据包都确确实实到达了接收端



3.用TCP协议一定不会丢包吗

TCP保证的可靠性，是**传输层的可靠性**；也就是说，**TCP只保证数据从A机器的传输层可靠地发到B机器的传输层**

聊天软件还需要将数据从TCP的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了



5.这种情况的丢包怎么办

![网络07](D:\02实习\02Notes\InterviewNotes\笔记图片\网络07.png)

服务器**可能**记录了我们最近发过什么数据，假设**每条消息都有个id**，服务器和聊天软件每次都拿**最新消息的id**进行对比，就能知道两端消息是否一致，就像**对账**一样



6.两端通信的时候也能对账，为什么还要引入第三端服务器

- 第一，如果是两端通信，你聊天软件里有`1000个`好友，你就得建立`1000个`连接。但如果引入服务端，你只需要跟服务器建立`1个`连接就够了，**聊天软件消耗的资源越少，手机就越省电** 
- 第二，就是**安全问题**， 引入第三方服务端就可以很方便的做各种**鉴权**校验。
- 第三，是**软件版本问题**。软件装到用户手机之后，软件更不更新就是由用户说了算了。如果还是两端通信，且两端的**软件版本跨度太大**，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件







**二、“https 和 http 相比，就是传输的内容多了对称加密，可以这么理解吗？**

1. 建立连接时候：https 比 http多了 **TLS握手过程**（验证身份、交换信息从而生成秘钥）；  
2. 传输内容的时候：https 会把数据进行加密，通常是对称加密数据

TLS  Transport Layer Security 的缩写 ，中文叫做 「传输层安全协议」

SSL 是洋文 Secure Sockets Layer 的缩写，中文叫做「安全套接层」 二者实际是一个东西

![网络06](D:\02实习\02Notes\InterviewNotes\笔记图片\网络06.png)





电路交换：专用物理线路，通信过程始终占据，利用率低

分组交换：分组有首部和尾部，包含源 目的地址，同线路允许同时传输多个分组

- 存储转发：收到数据先存储，将相同目的地的一起转发到下一个目的地



## 计算机网络体系

![网络01](D:\02实习\02Notes\1准备暑期实习\笔记图片\网络01.png)

应用层：为**特定应用程序**提供数据传输服务，例如 HTTP、DNS 等协议

传输层：为**进程**提供通用数据传输服务；由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议

- 传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为**报文段**
- 用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户**数据报**

网络层：为**主机**提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务

数据链路层：为**同一链路的主机**提供数据传输服务

物理层：在传输媒体上传输数据比特流



五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理

表示层：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题

会话层：建立及管理会话



数据在各层之间传输：在向下的过程中，需要添加下层协议所需要的首部或者尾部；在向上的过程中不断拆开首部和尾部



## 网络层

地址解析协议ARP：实现由 IP 地址得到 MAC 地址

网际控制报文协议ICMP：为了更有效地转发 IP 数据报和提高交付成功的机会，**它封装在 IP 数据报中**，但是不属于高层协议；ICMP 报文分为差错报告报文和询问报文

- Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性
- Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径

网络地址转换NAT ：本地 IP 转换为全球 IP，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址

用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP 地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换



路由器

- 功能上可以划分为：路由选择和分组转发

- 路由选择协议

  内部网关协议：RIP基于距离向量的路由选择协议；OSPF开放最短路径优先 

  外部网关协议：BGP边界网关协议



## 传输层

真正通信的是主机中的**进程**，传输层提供了进程间的逻辑通信

用户数据报协议 UDP：是无连接的，尽最大可能交付，没有拥塞控制，**面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）**，支持一对一、一对多、多对一和多对多的交互通信

传输控制协议 TCP：是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，**面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）**，每一条 TCP 连接只能是**点对点的（一对一）**

- **确认号** ：期望收到的下一个报文段的序号

- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1（ACK 在连接建立之后都为 1）
- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1



### **TCP UDP区别**

`TCP`  面向连接 可靠 稳定 ；在传递数据之前通过三次握手建立连接，在传输数据时 有确认、窗口、重传、拥塞控制 ；但缺点是 速度慢，占用系统资源较高

`UDP` 传输速度快，面向非连接，传输不可靠，传输时如果网络质量不好 容易丢包

当对网络通讯质量有要求的时候 使用 `TCP`

当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用`UDP`



### TCP三次握手

![网络02](D:\02实习\02Notes\1准备暑期实习\笔记图片\网络02.png)

假设 A 为客户端，B 为服务器端。

- 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。
- A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
- B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- A 收到 B 的连接确认报文后，**还要向 B 发出确认**，ACK=1 确认号为 y+1，序号为 x+1(ACK 在连接建立之后都为 1)
- B 收到 A 的确认后，连接建立



**三次握手原因** 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接



### TCP四次挥手

![网络03](D:\02实习\02Notes\1准备暑期实习\笔记图片\网络03.png)

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，**因为 ACK 在连接建立之后都为 1**

- A 发送连接释放报文，FIN=1
- B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据
- 当 B 不再需要连接时，发送连接释放报文，FIN=1
- A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- B 收到 A 的确认后释放连接

**TIME_WAIT**

- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文



**TCP可靠传输**：使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段

**TCP流量控制**：流量控制是为了控制发送方发送速率，保证接收方来得及接收；确认报文中的窗口字段可以用来控制发送方窗口大小

**TCP拥塞控制** 慢开始、拥塞避免、快重传、快恢复

- 慢开始 拥塞避免

  拥塞窗口cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 

  设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1

  **如果出现了超时**，则令 ssthresh = cwnd / 2，然后重新执行慢开始

- 快重传 快恢复

  在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段，在这种情况下，只是丢失个别报文段，而不是网络拥塞。**因此执行快恢复**，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免

  ![网络04](D:\02实习\02Notes\1准备暑期实习\笔记图片\网络04.png)

**慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh**



## 应用层

**域名系统** DNS 是一个分布式数据库，提供了**主机名和 IP 地址之间相互转换的服务**

DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输

在两种情况下会使用 TCP 进行传输：

- 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。
- 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）



**文件传输协议 FTP**

FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件

- 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。

- 数据连接：用来传送一个文件数据

  根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式

  主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机

  被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机



**动态主机配置协议DHCP**

用户不再需要手动配置 IP 地址等信息.



**远程登录协议Telnet**

**电子邮件协议** SMTP POP3 IMAP



![网络05](D:\02实习\02Notes\1准备暑期实习\笔记图片\网络05.png)





# `http和https`区别

HTTP协议以明文方式发送内容，不提供任何方式的数据加密

https则是具有安全性加密传输协议

http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443

http的连接很简单，是无状态的；HTTPS协议是由SSL（安全套接字协议）+HTTP协议构建的可进行加密传输、身份认证，比http协议安全



## 浏览器输入`url`并回车以后都发生了什么

1.浏览器解析 URL（统一资源定位符）， URL主要包括 传输协议、服务器、域名、端口、虚拟目录、文件名等；

2.然后，`DNS`解析（域名解析），依次检查 浏览器缓存、操作系统缓存、路由器缓存、 `ISP DNS`缓存、根域名服务器缓存；`DNS`服务器查询分为 递归查询 和 迭代查询

3.浏览器与网站建立 `TCP`连接（三次握手）

4.之后进行请求和传输数据，浏览器向服务器发送HTTP请求

5.接收到数据后浏览器渲染界面







## Web页面请求过程

1.**浏览器查询 DNS**，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系 统的DNS缓存、读取本地的Host文件和向**本地DNS服务器**进行查询等。对于向本地DNS服务器进 行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析 (此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网 址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）；如果本地域名服务 器并未缓存该网址映射关系，那么将**根据其设置发起递归查询或者迭代查询**；

2.浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手； 

3.TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求； 

4.服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应 的视图返回给浏览器； 

5.浏览器解析并渲染视图，若遇到对js文件、css文件及图片等**静态资源的引用**，则**重复上述步骤**并 向服务器请求这些资源； 

6.浏览器根据其请求到的资源、数据**渲染页面**，最终向用户呈现一个完整的页面。





**1.配置主机信息**

假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取

主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中

该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中

DHCP 服务器收到广播帧之后，生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码

主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关

**2.ARP解析MAC地址**

主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址

主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53

为了获取网关路由器的 MAC 地址，需要使用 ARP 协议（IP得到MAC

**3.DNS解析域名**

到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名

**4.HTTP请求页面**

有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文

在生成 TCP 套接字之前，必须先与 HTTP 服务器进行**三次握手来建立连接**

连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器

生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机

浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面



