## 三大特性

**封装** 将数据与代码进行有机的结合，形成类，其中数据和函数都是类的成员；目的在于将对象的使用者和设计者分开，可以隐藏实现细节，**增加代码安全，提高可维护性和可修改性**



**继承** 继承减少了重复的代码、继承是多态的前提、继承增加了类的耦合性

类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类称为派生类或子类，子类继承基类后，**可以创建子类对象来调用基类的函数，变量等**

- 单一继承、多重继承（类与类之间要用逗号隔开，类名之前要有继承权限，假使两个或两个基类都有某变量或函数，在子类中调用时需要加**类名限定符**）、菱形继承（需要用到虚继承）

  

**多态**  一个接口，多种方法；同一个接口，效果各不相同，多态有两种形式，一种是静态多态，一种是动态多态

- 静态多态：不需要共有基类，只需要各个具体类的实现中要求相同的接口声明
- 动态多态：一个共同功能集，然后在基类中，把这些共同的功能声明为多个公共的虚函数接口。**各个子类重写这些虚函数，以完成具体的功能**（**具体实现就是c++的虚函数**）
- 多态有几种：重载（函数重载、运算符重载）、虚函数、模板

**多态是以封装和继承为基础实现的性质**





## 构造函数、析构函数、拷贝构造函数等函数的作用

- **构造函数** 

  构造函数在创建一个对象时，系统自动调用; 如果用户没有自定义构造函数，系统会调用默认构造函数，默认构造函数会将所有数据成员初始化为0或者空

- **析构函数**

  析构函数没有返回值，也没有参数, 一个类中只能定义一个析构函数，若没有，系统会自动调用默认析构函数

  调用析构函数来删除创建的对象的资源空间

  **析构函数为什么定义为虚函数**

  析构函数定义成虚函数是为了防止内存泄漏， 当基类的指针 引用指向或绑定到派生类的对象时，如果未将基类的析构函数定义成虚函数，只会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏

- **拷贝构造函数**

  拷贝构造函数实际上也是构造函数，具有一般构造函数的所有特性，其名字也与所属类名相同

  目的是用一个已有的对象创建一个新的对象





## 面向对象和面向过程语言的区别

**面向过程**就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了

- 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素
- 缺点：没有面向对象易维护、易复用、易扩展

**面向对象**是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为

- 优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，**可以设计出低耦合的系统**，使系统 更加灵活、更加易于维护
- 缺点：性能比面向过程低



## 虚函数

在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数

虚函数的作用，**实现多态性** ，定义虚函数是为了允许**用基类的指针来调用子类的这个函数**

定义**纯虚函数**是为了实现一个接口，起到一个**规范的作用**，规范继承这个类的程序员**必须实现这个函数**

- 通常此类指针或引用都**声明为基类**的，它可以**指向基类或派生类的对象**





## Struct

结构体 `struct `  C++ 中允许同时出现函数和数据，**默认权限public**   C 中是将数据放在一起，没有函数

C++中struct可以继承class和struct，也可以被class和struct继承

struct是一个数据结构的实现体；而**class是一个对象的实现体**

- 默认权限：struct默认的访问权限是public的，class默认的访问权限是private的
- 默认的继承访问权限：取决于子类，而不是取决于基类； struct做子类的时候，默认是public的；class做子类的时候，默认是private的



## C++ JAVA

C++ 支持函数重载 和 运算符重载；这是 C++的突出特征

JAVA：不用对内存进行分配和回收 程序自动处理 不用考虑碎片问题；不支持运算符重载 ，

C++ 支持隐式类型转换 `java`必须显示进行强制转换



## Static

被此关键字修饰过的函数或变量,即为静态函数或静态变量.

**总的来说**

1.在修饰变量的时候，**static 修饰的静态局部变量只执行初始化一次**，而且延长了局部变量的生命周期，直到程序运行结束以后才释放，静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0

2.static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，未经初始化的静态全局变量会被程序自动初始化为0

3.static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用

4.考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）

**在 C++ 中**  static 关键字最基本的用法是：

在 C++ 中，静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用

- 1、被 static 修饰的变量属于类变量，可以通过**类名.变量名**直接引用，而不需要 new 出一个类来
- 2、被 static 修饰的方法属于类方法，可以通过**类名.方法名**直接引用，而不需要 new 出一个类来





## 结构体(struct)和共同体(union)的区别

结构体struct：把不同类型的数据组合成一个整体。**struct里每个成员都有自己独立的地址**。sizeof(struct)是内存对齐后所有成员长度的加和

共同体union：各成员共享一段内存空间, 一个union变量的长度等于各成员中最长的长度，以达到节省空间的目的；该union变量可被赋予任一成员值,但每次只能赋一种值, 赋入新值则冲去旧值



## 传递对象和对象引用

1.使用对象作为函数参数，形参和实参是不同的对象，它们所占地址空间不同，因此，形参的改变，并不影响实参的值

2.使用对象指针作为函数参数中，所谓"传址调用",就是在函数调用时使实参对象和形参对象的地址传递给函数，**形参和实参都指向同一个地址值**，此时在函数中对形参对象的修改将影响调用该函数的实参对象本身

3.使用对象引用作为函数的参数，所谓"对象引用"，就是对实参对象换了个别名，实际上它们仍是同一个对象，所以，所谓的形参(别名对象)值的的改变，直接就是实参对象值的改变



## 深浅拷贝（对于 对象和数组而言）

浅拷贝只**复制指向某个对象的指针**，而不复制对象本身，新旧对象还是共享同一块内存（分支）

深拷贝会另外**创造一个一模一样的对象**，新对象跟原对象不共享内存，修改新对象不会改到原对象，是“值”而不是“引用”



## 堆 栈 区别

管理方式不同：栈，由编译器自动管理，无需程序员手工控制；堆：产生和释放由程序员控制

栈不会产生碎片，因为栈是种先进后出的队列。堆则容易产生碎片，多次的`new/delete` 会造成内存的不连续，从而造成大量的碎片

堆的生长方式是**向上** 的，栈是向下的

**堆是动态分配的**   栈可以是静态分配和动态分配两种



## C 从源文件到可执行文件

预处理：编译器主要加载头文件 宏替换 等

编译：编译器做语法检查 和 词法分析，然后**生成汇编代码**

汇编：汇编代码 转为 机器代码

链接：将目标文件 启动代码 库文件**链接成可执行文件**



## new malloc 区别

**共同点是 **
都是从堆上申请空间，并且需要用户手动释放

**不同的地方是**

1.malloc和free是函数，new和delete是操作符

2.malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可

3.malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型

5.malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常

6.申请**自定义类型对象时**，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理



## 为什么要字节对齐

根本原因在于CPU访问数据的效率问题，**CPU访问非对齐的内存时需要多次读取再拼接**



## 编写 .h 头文件需要注意哪些环节

1）类声明部分写入.h头文件(header)，类实现写入.cpp源文件(source)

2）为头文件添加预编译头#ifndef，防止同一头文件被嵌套导入时发生问题，避免了重复声明造成的冲突

~~~C++
#ifndef xxx
#define xxx
 
//你的代码写在这里
 
#endif
~~~

3）类的接口部分、构造函数、析构函数作为公有部分(public)，其余的尽可能作为私有部分(private)



**为什么引用头文件会产生重复定义的问题**

声明可以有多次，但是定义只能有一次

1）变量定义：为变量**分配存储空间**，还可为变量指定**初始值**。程序中，变量有且仅有一个定义；**定义也是声明**

2）变量声明：向程序表明变量的**类型和名字**

3）*extern*关键字：通过使用*extern*关键字声明变量名而不定义它



**头文件如何避免内联函数出现重复定义的问题**

inline函数是个弱符号，重复定义以后链接期间不会报“对 xxx 多重定义”的错误

编译器优化开关关闭时，inline函数可能会被同名的其它函数替代，从而影响业务逻辑的正确性



## 为什么要设计单例类

单例模式是指在整个系统生命周期 内，保证一个类只能产生一个实例，确保该类的**唯一性**

单例模式是为了保证程序的**线程安全** 

**单例模式分类**

单例模式可以分为 **懒汉式** 和 **饿汉式** ，两者之间的区别在于创建实例的时间不同

- 懒汉式：系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例  **要考虑线程安全**
- 饿汉式：系统一运行，就初始化创建实例，当需要时，直接调用即可 **这种方式本身就线程安全，没有多线程的线程安全问题**

**单例类的特点**

- 构造函数和析构函数为私有类型，目的是禁止外部构造和析构。
- 拷贝构造函数和赋值构造函数是私有类型，目的是禁止外部拷贝和赋值，确保实例的唯一性。
- 类中有一个获取实例的静态方法，可以全局访问



## C++ 11有哪些新特性

- nullptr替代 NULL

  在C语言中，NULL被定义为(void\*)0,而在C++语言中，NULL则被定义为整数0

  nullptr可以明确区分整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何整型

- 引入了 auto 和 decltype 这两个关键字实现了类型推导

- 基于范围的 for 循环for(auto& i : res){}

- 类和结构体的中初始化列表

- Lambda 表达式（匿名函数）

- 智能指针

  unique_ptr 、shared_ptr、weak_ptr



## arr和&arr[0]和&arr的不同

如果打印的话，三个打印的完全一样，都是数组首元素的地址

```C++
printf("%p\n",arr);//首元素的地址
printf("%p\n",&arr[0]);//首元素的地址
printf("%p\n",&arr);//整个数组元素的地址
```

**&arr代表的是整个数组的地址，虽然它具体表现为首个元素的地址，但是在对其进行操作时，是以整个数组为单位的**



## char a,char a[],char *a,char *[],char * *a 之间的区别

1.char a：定义了一个存储空间，存储的是char类型的变量

2.char a[]：是一个字符数组，数组中的每一个元素是一个char类型的数据

3.char *a：a代表的也是字符串的首地址，**char a[]和char *a可以放到一块看，这两个没有本质区别**

4.char *a[]

```C++
// *的优先级是低于`[]`的，因此要先看`a[]`再看 `*
```

因此这**是一个char数组，数组中的每一个元素都是指针，这些指针指向char类型**

5.char **a

两个**代表相同的优先级，因此从右往左看，即`char*(*a)`

char *a不就是一个字符串数组，a代表首地址; 那么**char * (*a)就是和char *a[]一样的数据结构**



## 数组指针和指针数组

其实就是数组的指针和指针的数组

**数组的指针**：指向一个数组的指针就是数组指针

**指针的数组**：一个数组的每一个元素都是指针



## C++内存布局/程序分段

内存从上到下分别是：

- 栈stack |高地址|:**栈是从高到低增长的** ,保存函数的局部变量，参数以及返回值
- 堆heap :动态内存分配的都放在堆上 **堆是从低到高的**
- bss段: （Block Started by Symbol）存放程序中**未初始化的全局变量**的一块内存区域
- data段: static变量和所有初始化的全局变量
- 代码段text |低地址|

![C++01](D:\02实习\02Notes\1准备暑期实习\笔记图片\C++01.png)



## 智能指针

动态内存管理经常会出现两种问题：一种是忘记释放内存，会造成内存泄漏；一种是尚有指针引用内存的情况下就释放了它，就会产生引用非法内存的指针

引入智能指针的概念，智能指针的行为类似常规指针，区别是它负责**自动释放所指的对象**，更加容易（**更加安全**）的使用动态内存



## 红黑树

是一种**自平衡二叉查找树** 

它的**左右子树高差有可能大于 1**，所以红黑树**不是严格意义上的平衡二叉树（`AVL`）**



**有了二叉搜索树，为什么还需要平衡二叉树**

二叉搜索树容易退化成一条链，查找的时间复杂度从O(log2N)退化成O(N),引入对左右子树高度差有限制的平衡二叉树，保证查找操作的最坏时间复杂度也为O(log2N)

**有了平衡二叉树，为什么还需要红黑树**

- AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡
- 在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
- 红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，**整体性能**优于AVL
- 红黑树的红黑规则，保证最坏的情况下，也能在O(log2N) 时间内完成



应用：

STL中 set map 底层使用红黑树

Java中，TreeMap、TreeSet都使用红黑树作为底层数据结构

HashMap也引入了红黑树：当冲突的链表长度超过8时，自动转为红黑树

Linux底层的CFS进程调度算法中，vruntime（虚拟时钟）使用红黑树进行存储

（CFS 完全公平调度器，**调度器总是选择vruntime值最低的进程执行**

如果一个进程得以执行，随着时间的增长（即一个个tick的到来），其vruntime将不断增大。没有得到执行的进程vruntime不变）



### 实现m^n 高效

~~~C++
int pow(int m, int n) {
    int sum =  1, tmp = m;
    while(n) {
        if(n & 1 == 1) {
            sum *= tmp;
        }
        tmp *= tmp;
        n = n >> 1;
    }
    return sum;
}
~~~
