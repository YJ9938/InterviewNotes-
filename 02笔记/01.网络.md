## 什么是SSL/TLS

SSL代表安全套接字层。它是一种用于加密和验证应用程序（如浏览器）和Web服务器之间发送的数据的协议

身份验证 ， 加密Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制

SSL/TLS协议作用：认证用户和服务，加密数据，维护数据的完整性的应用层协议加密和解密需要两个不同的密钥，故被称为非对称加密；加密和解密都使用同一个密钥的



## HTTPS如何保证数据传输安全，流程怎么样

（1）客户端向服务器端发起SSL连接请求； （2） 服务器把公钥发送给客户端，并且服务器端保存着唯一的私钥 （3）客户端用公钥对双方通信的对称秘钥进行加密，并发送给服务器端 （4）服务器利用自己唯一的私钥对客户端发来的对称秘钥进行解密， （5）进行数据传输，服务器和客户端双方用公有的相同的对称秘钥对数据进行加密解密，可以保证在数据收发过程中的安全，即是第三方获得数据包，也无法对其进行加密，解密和篡改



## 如何保证公钥不被篡改

**将公钥放在数字证书中** 只要证书是可信的，公钥就是可信的。



## Cookie是什么

HTTP 协议是**无状态**的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务

Cookie 是**服务器发送到用户浏览器并保存在本地的一小块数据**，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器

cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。



## Session

除了可以将用户信息通过 **Cookie 存储在用户浏览器中**，也可以利用 **Session 存储在服务器端**，存储在服务器端的信息更加安全。

使用 Session 维护用户登录状态的过程如下：

1. 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；
2. 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；
3. 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；
4. 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作



## SQL注入

攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行

从两个方面同时入手

Web端 1）有效性检验   2）限制字符串输入的长度

服务端 1）不用拼接SQL字符串  2）使用预编译的PrepareStatement   3）有效性检验 (为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求) 4）过滤SQL需要的参数中的特殊字符  比如单引号、双引号



## RARP

反向地址转换协议，网络层协议，RARP与ARP工作方式相反。

ARP: 从IP 得到 MAC

RARP：从MAC得到IP

(1)网络上的每台设备都会有一个独一无二的硬件地址，通常是由设备厂商分配的MAC地址。主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包，请求RARP服务器回复该主机的IP地址

(2)RARP服务器收到了RARP请求数据包，为其分配IP地址，并将RARP回应发送给主机

(3)PC1收到RARP回应后，就使用得到的IP地址进行通讯



## DDos

客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，**客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认**



## 应用层协议

HTTP 80	HTTPS 443	Telent 23	FTP 20 21	TFTP 69

SMTP 25	POP 110	DNS 53



## TCP 挥手为什么要四次

因为当服务端收到客户端的SYN连接请求报文后，==可以直接发送SYN+ACK报文== 其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手

















