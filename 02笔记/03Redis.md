## 什么是Redis

一个高性能的 key-value 数据库

Redis 与其他 key - value 缓存产品有些特点

- Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用
- 不仅仅支持简单的 key-value 类型的数据， 同时还提供 list， set， zset， hash 等数据结构的存 储
-  支持数据的备份， 即 master-slave 模式的数据备份

优点：性能极高、丰富的数据类型、所有操作都是原子性的、丰富的特性（ key 过期等等特性）

不同：

- Redis 有着更为复杂的数据结构并且提供对他们的原子性操作
- 运行在内存中但是可以持久化到磁盘；相比在磁盘上相同的复杂的数据结构， 在内存中操作起来非常简单，这样 Redis 可以做很多内部复杂性很强的事情。同时， 在磁盘格式方面他 们是紧凑的以追加的方式产生的， 因为他们并不需要进行随机访问



## 数据类型

字符串string 哈希hash 列表list 集合set 有序集合zset



## Redis和memcached 有哪些优势

1.memcached值都是简单字符串，redis 作为其替代者， 支持更为丰富的数据类

2、Redis 的速度比 Memcached 快很

3、Redis 可以持久化其数据



## Redis和memcached 区别

1、存储方式 Memecache 把数据全部存在内存之中， 断电后会丢失，数据不能超过内存大小。 Redis 有部份存在硬盘上， 这样能保证数据的持久性

2、数据支持类型 Memcache 对数据类型支持相对简单；Redis 有复杂的数据类型



## 单线程

Redis 是单进程单线程的， redis 利用队列技术将并发访问变为串行访问， 消除了传统数据库串行 控制的开销



## Redis持久化机制 RDB AOF

1.RDB机制 

记录 redis 数据库的所 有键值对,在某个时间点将数据写入一个临时文件， 持久化结束后， 用这个文件替换上次持久化的 文件， 达到数据恢复

优点：方便持久化、性能最大化

不足：数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障， 会发生数据丢 失。所以这种方式更适合数据要求不严谨的时候.

2.AOF机制

是指所有的**命令行记录**以 redis 命令请求协议的格式完全持久 化存储)保存为 aof 文件

优点：数据安全

不足：AOF 文件比 RDB 文件大， 且恢复速度慢。 2、数据集大的时候， 比 rdb 启动效率低。



## redis 过期键的删除策略

1、定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时， 立即执行对键的删除操作

2、惰性删除:放任键过期不管，但是每**次从键空间中获取键时，都检查取得的键是 否过期**， 如果过期 的话， 就删除该键;如果没有过期， 就返回该键

3、定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至 于要删除多少过期 键， 以及要检查多少个数据库， 则由算法决定



## Redis 的回收策略（淘汰策略）

volatile-lru：从已设置过期时间的数据集（ server.db[i].expires）中挑选最近最少使用的数据淘汰 

volatile-ttl： 从已设置过期时间的数据集（ server.db[i].expires） 中**挑选将要过期的数据淘汰** 

volatile-random： 从已设置过期时间的数据集（ server.db[i].expires） 中任意选择数据淘汰

allkeys-lru： 从数据集（ server.db[i].dict） 中挑选最近最少使用的数据淘汰 

allkeys-random： 从数据集（ server.db[i].dict） 中任意选择数据淘汰 

no-enviction（ 驱逐） ： 禁止驱逐数据，永不回收策略



## 为什么 redis 需要把所有数据放到内存中

为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中， 磁盘 I/O 速度为严重影响 redis 的性 能。在内存越来越便宜的今天， redis 将会越来越受欢迎



## Redis 的同步机制了解么

Redis 可以使用主从同步，从从同步



## 怎么理解 Redis 事务

1） 事务是一个单独的隔离操作： 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程 中， 不会被其他客户端发送来的命令请求所打断

2） 事务是一个原子操作： 事务中的命令要么全部被执行， 要么全部都不执行



## 如果有大量的 key 需要设置同一时间过期，一般需要注意什 么

如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现 象。一般需要在时间上加一个随机值， 使得过期时间分散一些



## 解决Redis缓存和数据库值不一致问题

**一、一致性是什么，一致性包含了以下两种：**

1. 缓存中有数据，那么数据库的数据必须要和缓存的数据要一致
2. 缓存中没有数据，在数据库值必须要是最新的数据



同步写回策略：就是写入缓存时，必须要写入数据库，保证数据一致性。

异步写回策略：先写入缓存，等到缓存失效或者淘汰的时候，再写入数据库，此时如果还没有写入数据库，这样数据就会丢失，数据库就没有最新的值了



**二、删除数据时 怎么保持一致性**

1.先删数据库

- 会在一定事件内发生数据不一致问题，其他线程会在一小段时间读取缓存中旧值
- 当删除缓存出错，会造成旧数据一直读取；**解决** 启动新线程去一直删除操作，直到删除成功

2.先删缓存

- 会导致缓存出问题，这样会造成缓存被重新更新为旧值

  **解决**：延时操作是为了确保 修改数据库——>清空缓存前，这段时间内，其他事务的更新缓存操作已完成

- 后选择删除数据库时删除失败了，这样会造成缓存数据一直在数据库没有被删除，导致一直读取的时旧值

  **解决** 直到数据库更新成功，在去删除缓存；用到了缓存双删和消息中间件



问题：

1. 首先如果删除缓存，缓存缺失，会给数据库带来一定的压力。
2. 如果业务中读数据和写缓存的时间控制的不好设置，那么双删的等待时间就不好设置。

**如果必须一致**  当删除数据库的值时，其他客户端短暂把并发请求暂存，等数据库删除和缓存更新之后再去发起请求，从而保证数据的一致性。这样下来并发就减小了



综上使用**读写缓存读写并发**的时候，可以使用**消息中间件**来维护数据不一致问题，在读写模式下对业务造成的影响不是很大; 当使用**读写缓存写写并发**的时候，可以使用加**分布式锁**来维护数据不一致问题







 
