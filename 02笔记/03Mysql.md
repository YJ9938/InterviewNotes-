## 0414

 **事务**，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位

数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性

- 原子性（Atomicity）

  事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生

  **实现：undolog（回滚日志），操作异常 会反向执行undolog，数据恢复到操作之前**

- 一致性（Consistency）

  无论多少事务在执行，无论事务中有什么操作，执行之前、执行过程中、执行之后的任意时刻，数据库的状态都是一致且稳定的；比如转账，转账前两个账户余额之和是2000，转账之后余额之和也为2000

- 隔离性（Isolation） 

  多个事务**并发**访问时，事务之间是隔离的，相互独立，一个事务不应该影响其它事务运行效果

  **实现：写写隔离 通过锁；写读隔离通过MVCC**

  1.多个事务同时执行时，会有三大问题

  - 脏读：B读A未提交的数据
  - 不可重复读：对同一条数据进行两次读取，两次之间B事务读取数据并进行完整提交，A事务两次读取到不同的数据
  - 幻读：对同一集合数据进行两次读取，B事务在集合中增加或者删除部分数据，A事务两次读取到了数量不一致的行数据

  2.对此MySql提供四种隔离级别

  - 读未提交
  - 读已提交
  - 可重复读
  - 串行读

-  持久性（Durability）

  事务一旦提交，事务中所有更改便持久的保存在数据库之中，不会由于电源故障、系统崩溃等问题而发生变化

  **并不会被回滚**





**事务隔离级别**

- 读未提交-RU（Read Uncommit）

  A事务没提交，B事务就能读到（但是不能修改）

- 读已提交-RC（Read Comit）

  一个事务的更新操作结果只有在**该事务提交之后**，另一个事务才可能读取到同一笔数据更新后的结果

- 可重复读-RR（Read Repeat）

  在该隔离级别下，一个事务多次读同一个数据，**在这个事务还没结束时**，**其他事务不能访问该数据**(包括了读写)，这样就可以在同一个事务内两次读到的数据是一样的

- 可串行化-SE（serialization）

  事务只能一个接着一个地执行，不能并发执行

  单线程，没有并发



数据库并行四大问题

- **修改丢失**

  一个线程的事务**修改**了另一个线程中修改但未提交的数据

- 脏读

  一个线程的事务**读取**了另一个线程中修改但未提交的数据

- 不可重复读

  一个线程的事务**读取**了另一个线程中提交的update数据，导致同一个事务前后两次读取数据不一致

- 幻读

  一个线程的事务**读取**了另一个线程中提交的insert数据



**MVCC**

Multi-Version Concurrency Control，即 **多版本并发控制**



## 0329

## Mysql日志

1.bin log 二进制日志

记录所有**数据库表结构和表数据变更的二进制日志**，比如insert、update、delete、create、truncate等等操作

- 用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。
- 数据恢复，用于数据库的基于时间点的还原。



2.redo log 重做日志

innodb存储引擎提供维护的，此日志文件只存在于innodb存储引擎下

确保事务的 **持久性** redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，**根据redo log进行重做，从而达到事务的持久性这一特性**

3.**undo log 回滚日志**

保证数据的**原子性**，保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读

如果在一个事务中执行了多个包含update、insert、delete的语句时，由于事务具备原子性，如果其中一个语句执行失败，那么之前执行成功的语句要就要被回滚撤销掉，此时就会根据当前事务txid在undo log中查找到保存的日志进行执行回滚



## 存储引擎

1.MyISAM

B+树结构查找记录页，再根据记录页查找记录，支持全文索引 B树索引 数据压缩

2.Memory

数据存储在内存，可以提高数据访问速度

支持的数据类型有限制，支持的锁粒度为表级

3.InnoDB

只有InnoDB支持事务



MyISAM 和InnoDB对比

1.InnoDB支持事务，MyISAM不支持，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了

2.MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用

3.InnoDB支持外键，MyISAM不支持

4.InnoDB不支持FULLTEXT类型的索引

5.InnoDB支持行锁



## B树的不足

1.不适合范围查找，查询到某个数之后，如果要查询小于的数据，还得遍历左子树

2.节点除了存储索引，还存储数据本身，占用空间大，在存储同样大小的数据，B数会更高，稳定性更弱



## 什么是数据库

首先数据库不仅仅是一堆数据的集合，有两个重要组成部分：数据库和实例

1. 数据库：物理操作文件系统或者其他文件形式的集合
2. 实例：后台进程和共享内存区组成的运行态



## 什么是SQL；什么是MySQL

**sql是一种结构化查询语言**，用于在数据库中存储，查询和删除数据用的

mysql是一个数据库管理系统，开源免费



## MySQL都有哪些存储引擎

MyIsam InnoDB

**innoDB引擎存储结构**  在 InnoDB 存储引擎中，所有的数据都被**逻辑地**存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）



## 数据库ACID

**事务**，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位

数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性

- 原子性（Atomicity）

  事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生

- 一致性（Consistency）

  事务开始之前和事务结束以后，数据始终处于一致性状态，**不会出现数据丢失**

- 隔离性（Isolation）

  多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果

- 持久性（Durability）

  事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，**并不会被回滚**





## Mysql 内部架构

![数据库05](D:\02实习\02Notes\1准备暑期实习\笔记图片\数据库05.png)

 MySQL 的架构共分为两层：**Server 层和存储引擎层**

**1.Server 层负责建立连接、分析和执行 SQL**

主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等

所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等）都在 Server 层实现

**2.存储引擎层负责数据的存储和提取**

支持 InnoDB、MyISAM、Memory 等多个存储引擎， 现在最常用的存储引擎是 InnoDB

常说的索引数据结构，就是由存储引擎层实现的

InnoDB 支持索引类型是 B+树 ，且是默认使用，在数据表中创建的主键索引和二级索引默认使用B+ 树索引



**连接器** 

- 与客户端进行 TCP 三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限

**查询缓存**

如果 SQL 是查询语句 ，MySQL 就会先去查询缓存，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果

**解析sql： 解析器**

词法分析，识别关键字，构建语法树

语法分析，判断sql语句是否满足语法

**执行sql**

- **预处理器** 检查 SQL 查询语句中的表或者字段是否存在； 将 `select *` 中的 `*` 符号，扩展为表上的所有列
- **优化器 ** 将 SQL 查询语句的执行方案确定下来，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引
- **执行器** 执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的



## 执行一条 SQL 查询语句，期间发生了什么

- 连接器：建立连接，管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端



## Mysql 一行记录怎么存储的 





## 数据库的三大范式

**一范式就是属性不可分割**  第一范式是关系型数据库的基本要求，表示每一列都是不可分割的基本数据项

**二范式就是要有主键**,其他字段都完全依赖于主键

**三范式就是要消除传递依赖**, 确保数据表中的每一列数据都和主键直接相关，而不能间接相关

（满足第二范式，并且表中的列**不存在对非主键列的传递依赖**）

可以将客户编号作为一个外键和订单表建立相应的关系；而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段

![数据库01](D:\02实习\02Notes\1准备暑期实习\笔记图片\数据库01.png)



## mysql索引是什么；有哪几种类型；优缺点

**索引（Index）是帮助MySQL高效获取数据的数据结构**； 是**加快检索表中数据**的方法。对于一张表来说，如果不加索引的话就要从表的第一行开始查找，如果一个表有百万行的话效率会非常低。如果有了索引，利用数据结构就可以快速查找

**优缺点**

索引的优点：加快数据的检索速度

索引的缺点：创建和维护高效的索引表**比较麻烦**；占用物理空间

**索引的类型**

- 字段类型分类：
  1. 普通索引；没有任何约束，**允许空值和重复值，纯粹为了提高查询效率而存在**
  2. 唯一索引；在普通索引上加上数据不允许重复，允许为null
  3. 主键索引；在唯一索引上加上不允许为null，一个表只能有一个主键
  4. 全文索引； 
- 数据结构分类
  1. **B+tree索引**
  2. **Hash索引**
  3. **Full-text(全文)索引**
- 其他
  1. 聚簇索引
  2. 非聚簇索引







## B树 B+树 红黑树

**1.B-Tree**是为磁盘等外存储设备设计的一种平衡查找树，每个节点中不仅包含数据的key值，还有data值

![数据库02](D:\02实习\02Notes\1准备暑期实习\笔记图片\数据库02.png)



**2.B+Tree**是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构

B+Tree相对于B-Tree有几点不同：

1. 非叶子节点只存储键值信息。
2. 所有叶子节点之间都有链指针
3. 数据记录都存放在叶子节点中
4. B+的非叶子节点只进行数据索引，不会存实际的键值对应的数据，所有数据必须要到叶子节点才能获取到，所以每次数据查询的次数都一样

![数据库03](D:\02实习\02Notes\1准备暑期实习\笔记图片\数据库03.png)

**三层的B+树就可以存放千万级别的数据了**



**3.红黑树**（二叉搜索树

- 根节点是黑色，叶节点是不存储数据的黑色空节点
- 任何相邻的两个节点不能同时为红色， 红色节点的孩子是黑色
-  任意节点到 叶节点的路径 包含相同数量的黑色节点
- 左子树节点 都小于根节点，右子树都大于根节点





## B+树索引

![数据库07](D:\02实习\02Notes\1准备暑期实习\笔记图片\数据库07.png)

1. B+树能显著减少IO次数，提高效率
2. B+树的查询效率更加稳定，因为数据放在叶子节点（**双向链表 便于范围查询**
3. B+树能提高范围查询的效率，因为叶子节点指向下一个叶子节点

**B+树进行查询，从根节点开始 在节点中的页数据 进行二分查找，然后到对应页继续二分查找，最后在叶子节点内进行遍历查找**

BTree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(log_dN)；一般d大，所以 索引结构效率高

B+树 想方设法将数据去掉，使得节点里面全是索引(key)就行，因此d越大，$O(log_dN)$就会越小；对于 B+树而言，树的高度一般不超过 4 层，就可以满足千万级数据的存储

### 哈希索引

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快

哈希缺点：

1. Hash 索引**仅仅能满足等值查询**，不能使用范围查询。
2. Hash 索引无法被用来避免数据的排序操作，由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；
3. 当碰撞太高的话，性能不一定很好，比如拉链法，后面跟了一长串

### 聚簇索引和非聚簇索引

**聚簇索引**：将数据存储与索引放到了一块，找到索引也就找到了数据

**非聚簇索引**：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，**叶子节点存放的是主键值，而不是实际数据**

如果某个查询语句使用了非聚簇索引

- 查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作**「回表」**，也就是说要查两个 B+ 树才能查到数据
- 当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「**索引覆盖」**，也就是只需要查一个 B+ 树就能找到数据



## 数据库事务

**事务是并发控制的基本单位** 

事务他是一个操作序列，这些操作要么都执行，要么都不执行，是一个不可分割的单位

**四个特征**

1. 原子性；事务中的操作被看成一个逻辑单元，这个逻辑单元的操作要么全做，要么全不做。
2. 一致性；当对数据进行更改后，如果回滚会回到最初状态。
3. 隔离性；允许多个用户对同一个数据进行**并发访问同时不破坏数据的完整性和正确性**  同时并行事务的修改必须和其他并行事务独立。
4. 持久性；事务结束后，结果必须能持久保存



## 脏读 可重复读 幻读

**脏读** A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚，那么A事务读取到的数据就是脏数据

**可重复读** 事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容

**不可重复读**  **（前后多次读取，数据内容不一致）**是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响（另一个事务读取并修改，导致A事务两次读取不一样

**幻读 ** **（前后多次读取，数据总量不一致）** 事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样（就像产生了幻觉一样，平白无故的多了几条数据，成为幻读）







## 数据库锁机制

**悲观锁** ：每次获取数据的时候都会进行加锁操作，防止外界修改。由于该数据加锁，因此对改数据进行读写操作的其他进程会进入等待状态；**悲观锁的实现需要数据库的锁机制来完成**，只有数据库系统的锁机制才能保证访问的排他性

**乐观锁** ：在数据进行提交更新的时候，才会正式对数据的**冲突与否进行检测**，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做

**乐观锁和悲观锁在本质上并不是同一种东西，一个是一种思想，另一个是一种真正的锁，但是它们都是一种并发控制机制**



### 锁的种类

- **共享锁（读锁）**：允许事务对数据进行读取；
- **互斥锁（写锁）**：允许事务对数据进行删除或更新

可以在数据库中**并行读**，但是只能**串行写**

无论是共享锁还是互斥锁其实都只是**对某一个数据行进行加锁**



### 锁的粒度

**1.行锁**：行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。**行级锁能大大减少数据库操作的冲突，提高并发度**；其加锁粒度最小，但加锁的**开销也最大**，还会出现死锁。**行级锁分为共享锁和排他锁**

**2.表锁** 是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。**表级锁分为共享锁和排他锁**。开销小，加锁快；**不会出现死锁**；锁定粒度大，**发生锁冲突的概率最高，并发度最低**

**3.意向锁**

为了支持多粒度锁定，InnoDB 存储引擎引入了意向锁（Intention Lock）

1. **意向共享锁**：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁；
2. **意向互斥锁**：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁



## drop、truncate和delete的区别

- delete删除的过程是每次从表中删除一行，并且将该操作记录到日志中，**可以回滚**  
- truncate指一次性从表中删除所有的数据，不保存在日志中因此是不可恢复的。
- drop将表占用的空间删除掉



## 什么是视图;视图的使用场景有哪些

视图是一种**虚拟的表**，其内容由查询语句定义 ;同真实的表一样，视图包含一系列带有名称的列和行数据

**视图本身并不包含任何数据**，不在数据库中以存储的数据值集形式存在，**它只包含映射到基表的一个查询语句**，当基表数据发生变化，视图数据也随之变化

**为什么用视图** 简单的单表查询只需要遍历一个表，而复杂的多表查询需要将多个表连接起来进行查询任务;

对于复杂的查询事件，每次查询都需要编写MySQL代码效率低下;为了解决这个问题，数据库提供了视图功能

**常用场景：**视图适合于多表连接浏览时使用; **不适合增、删、改**





## mysql 记录存储

在对应目录下

- db.opt 存储当前数据库的默认字符集和字符校验规则
- xx.frm 存储表结构，保存每个表的元数据信息的，主要包含表结构定义
- xx.ibd **表数据**会保存在这个文件

**一、表空间文件的结构是怎么样的**

表空间由段（segment）、区（extent）、页（page）、行（row）组成

![数据库06](D:\02实习\02Notes\1准备暑期实习\笔记图片\数据库06.png)

- 行：数据库表中的记录都是按行（row）进行存放的

- 页：**InnoDB 的数据是按「页」为单位来读写的**，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存

  **默认每个页的大小为 16KB**，也就是最多能保证 16KB 的连续存储空间

  InnoDB 里的 B+ 树中的**每个节点都是一个数据页**

- 区：在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配；每个区的大小为 **1MB**，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了

- 段：由多个区（extent）组成的，段一般分为数据段、索引段和回滚段等



**二、InnoDB行格式**

Redundant、Compact、Dynamic和 Compressed 行

**compact行格式**

![数据库08](D:\02实习\02Notes\1准备暑期实习\笔记图片\数据库08.png)

- 变长字段长度列表：记录这一行数据中变长字段的各个长度， **只出现在数据表有变长字段的时候**

- NULL值列表：如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列， **NULL 值列表也不是必须的** ；通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）

- 记录头信息

  

 **三、varchar(n) 中 n 最大取值为多少**

- MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，**其他所有的列**（不包括隐藏列和记录头信息,**但是包含 变长字段长度列表 和 null值列表**）占用的字节长度加起来不能超过 65535 个字节（2^16-1)

  **超过了一页16KB**

  一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，注意是一行的总长度

  **因为 变长字段列表 和 NULL值列表都是可省略的，所以65535是包含这两个字段**

- varchar(n) 字段类型的 n 代表的是最多存储的**字符数量**

  varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集

**举例子**

~~~mysql
CREATE TABLE test ( 
`name` VARCHAR(65535)  NULL
) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
~~~

「变长字段长度列表」所占用的字节数 = 所有「变长字段长度」占用的字节数之和，

- 条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示
- 条件二：如果变长字段允许存储的最大字节数大于 255 字节

在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。所以，**在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 = 65535 - 2 - 1 = 65532**

如果采用的是 UTF-8，varchar(n) 最多能存储的数据计算方式就不一样了

- 在 UTF-8 字符集下，一个字符串最多需要三个字节，varchar(n) 的 n 最大取值就是 65532/3 = 21844。

上面所说的只是针对于一个字段的计算方式

**如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535**



**五、总结**

**1.MySQL 的 NULL 值是怎么存放的？**

MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，**NULL 值并不会存储**在行格式中的真实数据部分

NULL值列表会占用 至少1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。

**2.MySQL 怎么知道 varchar(n) 实际占用数据的大小？**

MySQL 的 Compact 行格式中会用「变长字段长度列表」**存储变长字段实际占用的数据大小**

**3.varchar(n) 中 n 最大取值为多少？**

一行记录最大能存储 65535 字节的数据，是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」

如果一张表只有一个 varchar(n) 字段，且允许为 NULL，**字符集为 ascii**，varchar(n) 中 n 最大取值为 65532

**5.行溢出 mysql怎么处理**

如果**一个数据页存不了一条记录**，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中

Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页

Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中
