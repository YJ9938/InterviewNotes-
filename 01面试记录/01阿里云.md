## 弹性计算 一面





## 云存储 一面 0220

![面试阿里云02](D:\02实习\02Notes\1准备暑期实习\笔记图片\面试阿里云02.jpg)

1.STL容器有哪些

STL有六大组件，但主要包含**容器、迭代器和算法**三个部分

- **容器**（Containers）：用来管理某类对象的集合
- **迭代器**（Iterators）：用来在一个对象集合的元素上进行遍历动作
- **算法**（Algorithms）：用来处理对象集合中的元素，比如 Sort，Search，Copy，Erase 那些元素



容器

- vector 向量，是一种序列式容器，事实上和数组差不多
  - 动态拓展、支持随机访问
  - 对头部和中间进行插入删除元素操作需要移动内存
  - 最后元素操作最快（在后面插入删除元素最快）
- dequeue 双端队列
  - 支持随机访问 即 【】
  - 可以在双端进行 pop push
  - 不适合中间插入删除操作
- list 由双向链表实现而成
  - 内存不连续，动态操作，可在任意位置插入或删除且效率高
  - 不支持随机访问
- set 集合 **由红黑树实现** 内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复
  - set 中的元素都是排好序的，集合中没有重复的元素
  - map 和 set 的插入删除效率比用其他序列容器高
  - **使用平衡二叉树实现**，便于元素查找，且保持了元素的**唯一性**，以及能**自动排序**
  - 每次插入值的时候，都需要调整红黑树，效率有一定影响
- map **红黑树实现** 每个元素有一个键，是排序准则的基础，每一个键只能出现一次，不允许重复
  - 用于资料一对一映射的情况，具有对数据自动排序的功能

容器配接器

- stack 栈
- queue 队列，FIFO先进先出
- priority_queue 



**2.STL无序容器实现**

unordered_map unordered_set 底层都是采用 **哈希表存储结构（链地址法、开链法**

整个存储过程分为如下几步：

1. 将该键值对中键的值带入设计好的哈希函数，会得到一个哈希值（一个整数，用 H 表示）；
2. 将 H 和无序容器拥有桶的数量 n 做整除运算（即 H % n），该结果即表示应将此键值对存储到的桶的编号；
3. 建立一个新节点存储此键值对，同时将该节点链接到相应编号的桶上



3.dequeue

deque 容器存储数据的空间是由一段一段等长的连续空间构成，用数组存储各个连续空间的首地址

当 deque 容器需要在**头部或尾部增加存储空间时**，它会申请一段新的连续空间，同时**在 map 数组的开头或结尾添加指向该空间的指针**，由此该空间就串接到了 deque 容器的头部或尾部



**5.static变量初始化**

在c语言中 static变量初始化是在代码执行前，在 编译期间初始化

C++中引入了对象，对象必须由构造函数生成，最终执行析构操作，何时执行全局、静态对象的构造 和析构，需要分析相关代码，无法在编译期完成

- 编译时初始化

  如果静态变量本身是基本数据类型(POD)，且初始化值是常量,那么这个初始化过程是在编译期间完成的

- 加载时初始化  **"饿汉式初始化"**

  **程序被加载时立即进行的初始化**，这个初始化发生在main函数之前，**即使程序任何地方都没访问过该变量**, 仍然会进行初始化 

  - 静态变量是一个基本数据类型，但是初始值非常量

    ~~~C++
    static int *p = new int[1024];
    
    int x = 3;
    int y = 4;
    static int z = x + y;
    ~~~

  - 静态变量是一个类对象，这种情况下即使是使用常量初始化，也是加载时初始化

    ~~~C++
    static std::string str = "Hello world !";
    
    class MyClass {
    public:	
    	MyClass();    
    	MyClass(int a, int b)
    ;};
    
    static MyClass* MyClass1 = new MyClass();  
    ~~~

- 运行时初始化  **"懒汉式初始化"**

  发生在变量第一次被引用，程序所在进程空间中，哪个线程先访问，就是哪个线程来初始化这个变量

  ~~~C++
  例1：
  int main()
  {
      for(int x = 5; x < 10; x++)
      {
          static int y = x;	//第一次被引用时初始化，并且只初始化一次
          cout << "x = " << x << ", y = " << y << endl;
      }
      return 0;
  }
  
  输出结果：
  x = 5, y = 5
  x = 6, y = 5
  x = 7, y = 5
  x = 8, y = 5
  x = 9, y = 5 
  ~~~

**总结**

1.如果是编译时和加载时初始化，是不会存在线程安全这个问题的；

因为这两种初始化一定发生在Main函数执行之前，这个时候尚未进入程序运行空间，而这些初始化一定是在单线程环境下操作的

2.如果是运行时初始化，因为无法保证访问这个静态变量一定只会从某个特定的线程中被访问，因此会存在"线程安全"的问题



## 为什么要设计单例类

单例模式是指在整个系统生命周期 内，保证一个类只能产生一个实例，确保该类的**唯一性**

单例模式是为了保证程序的**线程安全** 

**单例模式分类**

单例模式可以分为 **懒汉式** 和 **饿汉式** ，两者之间的区别在于创建实例的时间不同

- 懒汉式：系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例  **要考虑线程安全**
- 饿汉式：系统一运行，就初始化创建实例，当需要时，直接调用即可 **这种方式本身就线程安全，没有多线程的线程安全问题**

**单例类的特点**

- 构造函数和析构函数为私有类型，目的是禁止外部构造和析构。
- 拷贝构造函数和赋值构造函数是私有类型，目的是禁止外部拷贝和赋值，确保实例的唯一性。
- 类中有一个获取实例的静态方法，可以全局访问



6.new/delete  malloc/free区别

**共同点是 **
都是从堆上申请空间，并且需要用户手动释放

**不同的地方是**

1.malloc和free是函数，new和delete是操作符

2.malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可

3.malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型

5.malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常

6.申请**自定义类型对象时**，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理



7.手动调用 构造函数、析构函数

对象定义：申请对象的空间并调用构造函数，

- 第一步，必须申请对象所占用的内存空间；
- 第二步，调用构造函数

对象声明：告诉编译器存在这样一个对象



~~~C++
#include <iostream>
 
class A{
public: 
    A():a(0),b(0){std::cout<<"调用第一个构造函数"<<std::endl;}
    A(int x):a(x),b(x+1){std::cout<<"调用第二个构造函数"<<std::endl;}
    ~A(){std::cout<<"调用析构函数"<<std::endl;}
    int geta(){
        return a;
    }
    int getb(){
        return b;
    }
private:
    int a;
    int b;
};
int main()
{
    A test;//在声明test的时候，调用了第一个构造函数
    test = A(5);//调用了第二个构造函数
    //实际是编译器生成了一个临时对象，是这个临时对象调用了第二个构造函数
    //在没有自己写拷贝构造函数和operator=这两个函数的时候，编译器会自动生成，这个时候的拷贝都是浅拷贝
    //编译器执行A(5)的时候创建了一个临时的对象，然后通过编译器自己生成的operator=函数把这个临时对象的值赋给了test，最后析构这个临时对象 
    std::cout<<test.geta()<<std::endl;
    std::cout<<test.getb()<<std::endl;
    return 0;
 
}

调用第一个构造函数
调用第二个构造函数
调用析构函数
5
6
调用析构函数
~~~



8.shell命令





9.Linux 64位系统 16G内存，能创建多少线程

[被问懵了：一个进程最多可以创建多少个线程？ - 小林coding - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiaolincoding/p/15013929.html)

一个进程能够创建的线程数，由**可用虚拟空间和线程的栈大小共同决定** 

Linux中 虚拟地址空间的内部被分为 内核空间 和 用户空间 两部分

- 32位系统 内核1G位于最高处，剩下3G是用户空间
- 64位系统 内核 和 用户 空间都是 128T，分别占据内存空间最高和最低；剩下的中间部分是未定义的

**一个进程最多可以创建多少个线程**

- **进程的虚拟内存空间上限**，因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多
- **系统参数限制**，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数



32位系统：

**一个进程的虚拟空间是 4G**，内核分走了1G，留给用户用的只有 3G 

那么假设创建一个线程需要占用 10M 虚拟内存（可以调整创建线程是分配的栈空间大小），总共有 3G 虚拟内存可以使用。于是我们可以算出，最多可以创建差不多 300 个（3G/10M）左右的线程



64位系统：

例子中，物理内存只有2G 但进程的虚拟内存可以有25T：虚拟内存并不是全部都映射到物理内存的，程序是有局部性的特性，也就是某一个时间只会执行部分代码，所以只需要映射这部分程序就好



简单总结下：

- 32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 **300 个左右的线程**
- 64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，会受系统的参数或性能限制，**经测试 大概是几万个线程**





## 云原生 0224

1.TCP三次握手



2.TCP可靠体现在哪些方面

- 数据被分割成合适的数据块
- 确认响应：对于一个收到的请求，将发送一个确认
- 超时重传: 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认,将重发这个报文段
- TCP给发送的每一一个包进行编号 ,接收方对数据包进行**排序**,把有序数据传送给应用层
- **校验和**: TCP将保持它首部和数据的检验和，目的是检测数据在传输过程中的任何变化
- IP数据报会发生重复，TCP的接收端会**丢弃重复的数据**
- **流量控制**: TCP连接的每一方都有固定大小的缓冲空间 , TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据



**tcp面向字节流** TCP将应用程序看成是一连串的无结构的字节流， 每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去

**udp面向报文**  应用层交给UDP多长的报文，UDP照样发送，既不拆分，也不合并，而是保留这些报文的边界，即一次发送一个报文



3.HTTP 的 GET POST PUT 的区别

GET请求：只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容

PUT请求：PUT请求是向服务器端发送数据的，从而改变信息，该请求就**像数据库的update操作一样**

Post请求：同PUT请求类似，是向服务器端发送数据，会改变数据的种类等资源，**像数据库的insert操作一样**，会创建新的内容



GET参数通过URL传递，POST放在Request body中





5.Linux常用命令

~~~shell
man  #显示其他命令的手册
touch #新建文件
chmod #修改文件权限  
	chmod +x script
sudo #允许您在运行特定命令时充当超级用户或根用户
ps #查看当前shell会话正在运行的进程
kill #关闭某个进程
ping #请求网址 测试连接
more # 只能不断向后翻看
less # 既可以向后翻看，也可以向前翻看
grep # 搜索与正则表达式匹配的行并打印它们
wc # 返回文本文件中的字数
find #根据regex表达式在目录层次结构中搜索文件
~~~







6.进程间通信 哪些方式

**进程之间要通信必须通过内核**

- 管道：**管道传输数据是单向的**，如果想相互通信，我们需要创建两个管道才行； 通信方式**效率低**，不适合进程间频繁地交换数据

- 消息队列：**消息队列是保存在内核中的消息链表**（全双工）

  不足：一是通信**不及时**，消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程

  二是附件也有大小限制，不适合比较大数据的传输

- 共享内存：**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**

  多个进程同时修改同一个共享内存，可能会有冲突

- 信号量：**是一个整型的计数器，主要用于实现进程间的互斥与同步**

  P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的

  信号量初始化1，可以实现 互斥访问

  初始化为0 可以实现进程同步

- 信号：信号是进程间通信机制中**唯一的异步通信机制**

  信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件

- socket：**跨网络与不同主机上的进程之间通信**，还可以用于本地主机进程间通信

  

线程间通信

**同个进程下的线程之间都是共享进程的资源**，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：

- 互斥的方式，可保证任意时刻只有一个线程访问共享资源；
- 同步的方式，可保证线程 A 应在线程 B 之前执行





7.GO语言中的channel

使用Channel通道来实现Goroutines之间的通信

要传递某个数据给另一个goroutine(协程)，可以把这个数据封装成一个对象，然后把这个对象的指针传入某个channel中，另外一个goroutine从这个channel中读出这个指针，并处理其指向的内存对象

Go从语言层面保证同一个时间只有一个goroutine能够访问channel里面的数据





8.Golang的运行时 **runtime**

它是Go程序执行时使用到的库， **控制非常重要的内容** 垃圾回收，内存管理，goroutine调度等

**常用函数**

- **NumCPU：**返回当前系统的 CPU 核数量
- **GOMAXPROCS：**设置最大的可同时使用的 CPU 核数
- **Goexit：**退出当前 goroutine(但是defer语句会照常执行)
- **runtime.GC：**会让运行时系统进行一次强制性的垃圾收集



9.打开网页 涉及到哪些协议

- 浏览器解析 URL（统一资源定位符），主要包括 传输协议、服务器、域名、端口、虚拟目录、文件名等

- 浏览器查询 DNS 浏览器搜索自身的DNS缓存、搜索操作系 统的DNS缓存、**读取本地的Host文件**和向本地DNS服务器进行查询等

- 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手

- ARP解析MAC地址

  为了获取网关路由器的 MAC 地址，需要使用 ARP 协议（IP得到MAC

  

域名解析

- 递归：DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机；如果服务器本地没有存储查询的DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机
- 迭代：DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，**而是告诉客户机另一台DNS 服务器地址**，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果



10.深浅拷贝



11.常用的排序算法

![C++02](D:\02实习\02Notes\1准备暑期实习\笔记图片\C++02.png)

稳定 ：冒泡、直接插入、归并、基数排序

不稳定 ：选择、快排、堆排、希尔



## 云网络 研发 0224

