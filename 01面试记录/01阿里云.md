## 弹性计算 一面



### 1.go协程

[一文看懂Go语言协程的设计与原理 - 掘金 (juejin.cn)](https://juejin.cn/post/7044741465930465311)

协程作为用户态线程，也是轻量级的线程，**用来解决高并发场景下线程切换的资源开销**

协程跟线程是有区别的

- 线程/进程是内核进行调度，有 CPU 时间片的概念，进行 抢占式调度（有多种调度算法）
- **协程 对内核是透明的**，也就是系统并不知道有协程的存在，是完全由用户**自己的程序进行调度**，因为是由用户程序自己控制，那么就很难像抢占式调度那样做到强制的 CPU 控制权切换到其他进程/线程，通常只能进行 协作式调度，需要协程自己主动把控制权转让出去之后，其他协程才能被执行到

 

**goroutine存在的意义是什么**

1.操作系统线程的创建和切换都需要进入内核，而进入内核所消耗的性能代价比较高，开销较大

2.内核在创建操作系统线程时默认会为其分配一个较大的栈内存，同时会有溢出的风险

**goroutine的优势也就是 开销小**

1.goroutine是用户态线程，其创建和切换都在用户代码中完成而无需进入操作系统内核，所以其开销要远远小于系统线程的创建和切换

2.**goroutine启动时默认栈大小只有2k**，这在多数情况下已经够用了，即使不够用，goroutine的栈也会自动扩大





## 云存储 一面 0220

![面试阿里云02](D:\02实习\02Notes\1准备暑期实习\笔记图片\面试阿里云02.jpg)

1.STL容器有哪些

STL有六大组件，但主要包含**容器、迭代器和算法**三个部分

- **容器**（Containers）：用来管理某类对象的集合
- **迭代器**（Iterators）：用来在一个对象集合的元素上进行遍历动作
- **算法**（Algorithms）：用来处理对象集合中的元素，比如 Sort，Search，Copy，Erase 那些元素



容器

- vector 向量，是一种序列式容器，事实上和数组差不多
  - 动态拓展、支持随机访问
  - 对头部和中间进行插入删除元素操作需要移动内存
  - 最后元素操作最快（在后面插入删除元素最快）
- dequeue 双端队列
  - 支持随机访问 即 【】
  - 可以在双端进行 pop push
  - 不适合中间插入删除操作
- list 由双向链表实现而成
  - 内存不连续，动态操作，可在任意位置插入或删除且效率高
  - 不支持随机访问
- set 集合 **由红黑树实现** 内部元素依据其值自动排序，每个元素值只能出现一次，不允许重复
  - set 中的元素都是排好序的，集合中没有重复的元素
  - map 和 set 的插入删除效率比用其他序列容器高
  - **使用平衡二叉树实现**，便于元素查找，且保持了元素的**唯一性**，以及能**自动排序**
  - 每次插入值的时候，都需要调整红黑树，效率有一定影响
- map **红黑树实现** 每个元素有一个键，是排序准则的基础，每一个键只能出现一次，不允许重复
  - 用于资料一对一映射的情况，具有对数据自动排序的功能

容器配接器

- stack 栈
- queue 队列，FIFO先进先出
- priority_queue 



**2.STL无序容器实现**

unordered_map unordered_set 底层都是采用 **哈希表存储结构（链地址法、开链法**

整个存储过程分为如下几步：

1. 将该键值对中键的值带入设计好的哈希函数，会得到一个哈希值（一个整数，用 H 表示）；
2. 将 H 和无序容器拥有桶的数量 n 做整除运算（即 H % n），该结果即表示应将此键值对存储到的桶的编号；
3. 建立一个新节点存储此键值对，同时将该节点链接到相应编号的桶上



3.dequeue

deque 容器存储数据的空间是由一段一段等长的连续空间构成，用数组存储各个连续空间的首地址

当 deque 容器需要在**头部或尾部增加存储空间时**，它会申请一段新的连续空间，同时**在 map 数组的开头或结尾添加指向该空间的指针**，由此该空间就串接到了 deque 容器的头部或尾部



**5.static变量初始化**

在c语言中 static变量初始化是在代码执行前，在 编译期间初始化

C++中引入了对象，对象必须由构造函数生成，最终执行析构操作，何时执行全局、静态对象的构造 和析构，需要分析相关代码，无法在编译期完成

- 编译时初始化

  如果静态变量本身是基本数据类型(POD)，且初始化值是常量,那么这个初始化过程是在编译期间完成的

- 加载时初始化  **"饿汉式初始化"**

  **程序被加载时立即进行的初始化**，这个初始化发生在main函数之前，**即使程序任何地方都没访问过该变量**, 仍然会进行初始化 

  - 静态变量是一个基本数据类型，但是初始值非常量

    ~~~C++
    static int *p = new int[1024];
    
    int x = 3;
    int y = 4;
    static int z = x + y;
    ~~~

  - 静态变量是一个类对象，这种情况下即使是使用常量初始化，也是加载时初始化

    ~~~C++
    static std::string str = "Hello world !";
    
    class MyClass {
    public:	
    	MyClass();    
    	MyClass(int a, int b)
    ;};
    
    static MyClass* MyClass1 = new MyClass();  
    ~~~

- 运行时初始化  **"懒汉式初始化"**

  发生在变量第一次被引用，程序所在进程空间中，哪个线程先访问，就是哪个线程来初始化这个变量

  ~~~C++
  例1：
  int main()
  {
      for(int x = 5; x < 10; x++)
      {
          static int y = x;	//第一次被引用时初始化，并且只初始化一次
          cout << "x = " << x << ", y = " << y << endl;
      }
      return 0;
  }
  
  输出结果：
  x = 5, y = 5
  x = 6, y = 5
  x = 7, y = 5
  x = 8, y = 5
  x = 9, y = 5 
  ~~~

**总结**

1.如果是编译时和加载时初始化，是不会存在线程安全这个问题的；

因为这两种初始化一定发生在Main函数执行之前，这个时候尚未进入程序运行空间，而这些初始化一定是在单线程环境下操作的

2.如果是运行时初始化，因为无法保证访问这个静态变量一定只会从某个特定的线程中被访问，因此会存在"线程安全"的问题



## 为什么要设计单例类

单例模式是指在整个系统生命周期 内，保证一个类只能产生一个实例，确保该类的**唯一性**

单例模式是为了保证程序的**线程安全** 

**单例模式分类**

单例模式可以分为 **懒汉式** 和 **饿汉式** ，两者之间的区别在于创建实例的时间不同

- 懒汉式：系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例  **要考虑线程安全**
- 饿汉式：系统一运行，就初始化创建实例，当需要时，直接调用即可 **这种方式本身就线程安全，没有多线程的线程安全问题**

**单例类的特点**

- 构造函数和析构函数为私有类型，目的是禁止外部构造和析构。
- 拷贝构造函数和赋值构造函数是私有类型，目的是禁止外部拷贝和赋值，确保实例的唯一性。
- 类中有一个获取实例的静态方法，可以全局访问



6.new/delete  malloc/free区别

**共同点是 **
都是从堆上申请空间，并且需要用户手动释放

**不同的地方是**

1.malloc和free是函数，new和delete是操作符

2.malloc申请空间时，需要手动计算空间大小并传递，new只需在其后跟上空间的类型即可

3.malloc的返回值为void*, 在使用时必须强转，new不需要，因为new后跟的是空间的类型

5.malloc申请空间失败时，返回的是NULL，因此使用时必须判空，new不需要，但是new需要捕获异常

6.申请**自定义类型对象时**，malloc/free只会开辟空间，不会调用构造函数与析构函数，而new在申请空间后会调用构造函数完成对象的初始化，delete在释放空间前会调用析构函数完成空间中资源的清理



7.手动调用 构造函数、析构函数

对象定义：申请对象的空间并调用构造函数，

- 第一步，必须申请对象所占用的内存空间；
- 第二步，调用构造函数

对象声明：告诉编译器存在这样一个对象



~~~C++
#include <iostream>
 
class A{
public: 
    A():a(0),b(0){std::cout<<"调用第一个构造函数"<<std::endl;}
    A(int x):a(x),b(x+1){std::cout<<"调用第二个构造函数"<<std::endl;}
    ~A(){std::cout<<"调用析构函数"<<std::endl;}
    int geta(){
        return a;
    }
    int getb(){
        return b;
    }
private:
    int a;
    int b;
};
int main()
{
    A test;//在声明test的时候，调用了第一个构造函数
    test = A(5);//调用了第二个构造函数
    //实际是编译器生成了一个临时对象，是这个临时对象调用了第二个构造函数
    //在没有自己写拷贝构造函数和operator=这两个函数的时候，编译器会自动生成，这个时候的拷贝都是浅拷贝
    //编译器执行A(5)的时候创建了一个临时的对象，然后通过编译器自己生成的operator=函数把这个临时对象的值赋给了test，最后析构这个临时对象 
    std::cout<<test.geta()<<std::endl;
    std::cout<<test.getb()<<std::endl;
    return 0;
 
}

调用第一个构造函数
调用第二个构造函数
调用析构函数
5
6
调用析构函数
~~~



8.shell命令





9.Linux 64位系统 16G内存，能创建多少线程

[被问懵了：一个进程最多可以创建多少个线程？ - 小林coding - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiaolincoding/p/15013929.html)

一个进程能够创建的线程数，由**可用虚拟空间和线程的栈大小共同决定** 

Linux中 虚拟地址空间的内部被分为 内核空间 和 用户空间 两部分

- 32位系统 内核1G位于最高处，剩下3G是用户空间
- 64位系统 内核 和 用户 空间都是 128T，分别占据内存空间最高和最低；剩下的中间部分是未定义的

**一个进程最多可以创建多少个线程**

- **进程的虚拟内存空间上限**，因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多
- **系统参数限制**，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数



32位系统：

**一个进程的虚拟空间是 4G**，内核分走了1G，留给用户用的只有 3G 

那么假设创建一个线程需要占用 10M 虚拟内存（可以调整创建线程是分配的栈空间大小），总共有 3G 虚拟内存可以使用。于是我们可以算出，最多可以创建差不多 300 个（3G/10M）左右的线程



64位系统：

例子中，物理内存只有2G 但进程的虚拟内存可以有25T：虚拟内存并不是全部都映射到物理内存的，程序是有局部性的特性，也就是某一个时间只会执行部分代码，所以只需要映射这部分程序就好



简单总结下：

- 32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 **300 个左右的线程**
- 64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，会受系统的参数或性能限制，**经测试 大概是几万个线程**





## 云原生 0224

1.TCP三次握手



2.TCP可靠体现在哪些方面

- 数据被分割成合适的数据块
- 确认响应：对于一个收到的请求，将发送一个确认
- 超时重传: 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认,将重发这个报文段
- TCP给发送的每一一个包进行编号 ,接收方对数据包进行**排序**,把有序数据传送给应用层
- **校验和**: TCP将保持它首部和数据的检验和，目的是检测数据在传输过程中的任何变化
- IP数据报会发生重复，TCP的接收端会**丢弃重复的数据**
- **流量控制**: TCP连接的每一方都有固定大小的缓冲空间 , TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据



**tcp面向字节流** TCP将应用程序看成是一连串的无结构的字节流， 每个TCP套接口有一个发送缓冲区，如果字节流太长时，TCP会将其拆分进行发送。当字节流太短时，TCP会等待缓冲区中的字节流达到一定程度时再构成报文发送出去

**udp面向报文**  应用层交给UDP多长的报文，UDP照样发送，既不拆分，也不合并，而是保留这些报文的边界，即一次发送一个报文



3.HTTP 的 GET POST PUT 的区别

GET请求：只是用来查询一下数据，不会修改、增加数据，不会影响资源的内容

PUT请求：PUT请求是向服务器端发送数据的，从而改变信息，该请求就**像数据库的update操作一样**

Post请求：同PUT请求类似，是向服务器端发送数据，会改变数据的种类等资源，**像数据库的insert操作一样**，会创建新的内容



GET参数通过URL传递，POST放在Request body中





5.Linux常用命令

~~~shell
man  #显示其他命令的手册
touch #新建文件
chmod #修改文件权限  
	chmod +x script
sudo #允许您在运行特定命令时充当超级用户或根用户
ps #查看当前shell会话正在运行的进程
kill #关闭某个进程
ping #请求网址 测试连接
more # 只能不断向后翻看
less # 既可以向后翻看，也可以向前翻看
grep # 搜索与正则表达式匹配的行并打印它们
wc # 返回文本文件中的字数
find #根据regex表达式在目录层次结构中搜索文件
~~~







6.进程间通信 哪些方式

**进程之间要通信必须通过内核**

- 管道：**管道传输数据是单向的**，如果想相互通信，我们需要创建两个管道才行； 通信方式**效率低**，不适合进程间频繁地交换数据

- 消息队列：**消息队列是保存在内核中的消息链表**（全双工）

  不足：一是通信**不及时**，消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程

  二是附件也有大小限制，不适合比较大数据的传输

- 共享内存：**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**

  多个进程同时修改同一个共享内存，可能会有冲突

- 信号量：**是一个整型的计数器，主要用于实现进程间的互斥与同步**

  P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的

  信号量初始化1，可以实现 互斥访问

  初始化为0 可以实现进程同步

- 信号：信号是进程间通信机制中**唯一的异步通信机制**

  信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件

- socket：**跨网络与不同主机上的进程之间通信**，还可以用于本地主机进程间通信

  

线程间通信

**同个进程下的线程之间都是共享进程的资源**，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：

- 互斥的方式，可保证任意时刻只有一个线程访问共享资源；
- 同步的方式，可保证线程 A 应在线程 B 之前执行





7.GO语言中的channel

使用Channel通道来实现Goroutines之间的通信

要传递某个数据给另一个goroutine(协程)，可以把这个数据封装成一个对象，然后把这个对象的指针传入某个channel中，另外一个goroutine从这个channel中读出这个指针，并处理其指向的内存对象

Go从语言层面保证同一个时间只有一个goroutine能够访问channel里面的数据





8.Golang的运行时 **runtime**

它是Go程序执行时使用到的库， **控制非常重要的内容** 垃圾回收，内存管理，goroutine调度等

**常用函数**

- **NumCPU：**返回当前系统的 CPU 核数量
- **GOMAXPROCS：**设置最大的可同时使用的 CPU 核数
- **Goexit：**退出当前 goroutine(但是defer语句会照常执行)
- **runtime.GC：**会让运行时系统进行一次强制性的垃圾收集



9.打开网页 涉及到哪些协议

- 浏览器解析 URL（统一资源定位符），主要包括 传输协议、服务器、域名、端口、虚拟目录、文件名等

- 浏览器查询 DNS 浏览器搜索自身的DNS缓存、搜索操作系 统的DNS缓存、**读取本地的Host文件**和向本地DNS服务器进行查询等

- 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手

- ARP解析MAC地址

  为了获取网关路由器的 MAC 地址，需要使用 ARP 协议（IP得到MAC

  

域名解析

- 递归：DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机；如果服务器本地没有存储查询的DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机
- 迭代：DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，**而是告诉客户机另一台DNS 服务器地址**，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果



10.深浅拷贝



11.常用的排序算法

![C++02](D:\02实习\02Notes\1准备暑期实习\笔记图片\C++02.png)

稳定 ：冒泡、直接插入、归并、基数排序

不稳定 ：选择、快排、堆排、希尔





## 云网络 研发 0224

**1.关键字搜索 模糊搜索**



**mysql能不能支持模糊搜索**

LIKE关键字 和 两个通配符

~~~mysql
# _：任意一个字符，
# %：任意0或多个字符

# 1.使用LIKE和通配符 _
# 需要确定想要搜索的个数，否则查询不到 ！！！
# 搜索一个名字，只知道是3个字符的，那怎么搜索呢（三个下划线 _）
SELECT * FROM test WHERE name LIKE'___';

# 一个名字总共是3个字符的，可是我只记得第一个字符是 c 
SELECT * FROM test WHERE name LIKE'c__';

# 2.使用LIKE和通配符 %

# 搜索一个名字只知道开头是一的字，后面是什么字，有多少个字符都不知道
SELECT * FROM test WHERE name LIKE'一%';

# 搜索一个名字只知道最后一个是子的字，前面是什么字，有多少个字符也都不知道
SELECT * FROM test WHERE name LIKE'%子';


~~~





**2.C C++中 struct class的区别**



static关键字



虚函数

纯虚函数

类里面析构函数 是不是应该设置为虚函数

**智能指针**

怎么样会出现野指针



**3.线程池**



线程间切换的开销



**5.mysql数据结构 **

innodb存储结构：数据库的存储结构 页



建立索引 根据哪些原则

复合索引

联合索引，怎么匹配判断



**6.tcp**

滑动窗口怎么保障tcp可靠性



**7.基于udp协议实现可靠传输**

**QUIC协议**

- Packet Number 单调递增的两个好处：
  - 可以更加精确计算 RTT，没有 TCP 重传的歧义性问题；
  - 可以支持乱序确认，因为丢包重传将当前窗口阻塞在原地，而 TCP 必须是顺序确认的，丢包时会导致窗口不滑动
- QUIC 通过单向递增的 Packet Number，**配合 Stream ID 与 Offset 字段信息**，可以支持乱序确认而不影响数据包的正确组装
  - Stream ID 作用：多个并发传输的 HTTP 消息，通过不同的 Stream ID 加以区别，类似于 HTTP2 的 Stream ID；
  - Offset 作用：类似于 TCP 协议中的 Seq 序号，**保证数据的顺序性和可靠性**；







粘包的问题 怎么处理

- tcp 遇到怎么处理
- udp 怎么处理



tcp中报文长度是由什么控制的



**8.HTTP/1.1  2  3**

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

- 使用**长连接**的方式改善了 HTTP/1.0 短连接造成的性能开销 
- 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间 （**可能存在 队头阻塞**



**HTTP/2 协议是基于 HTTPS 的**，所以 HTTP/2 的安全性也是有保障的

HTTP/2 相比 HTTP/1.1 性能上的改进：

- 头部压缩; 同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**

  在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就**提高速度**了

- 二进制格式, **（更加安全）**直接解析二进制报文，这**增加了数据传输的效率**

- 并发传输,  针对不同的 HTTP 请求用独一无二的 Stream ID 来区分 （**解决 HTTP这一层的队头阻塞**

- 服务器主动推送资源;  服务端不再是被动地响应，可以**主动**向客户端发送消息

**依然存在队头阻塞 TCP这一层**





**HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP**

- 基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输
- QUIC 有以下 3 个特点 
  - 无队头阻塞 ：QUIC 给每一个 Stream 都分配了一个独立的滑动窗口，这样使得一个连接上的多个 Stream 之间没有依赖关系，都是**相互独立的，各自控制的滑动窗口**
  - 更快的连接建立
  - 连接迁移







## 云网络 二面 0227

主要是讲项目



**1.如何设计一个缓存策略，可以动态缓存热点数据呢？**

由于数据存储受限，系统并不是将所有数据都需要存放到缓存中的，而**只是将其中一部分热点数据缓存起来**，所以我们要设计一个热点数据动态缓存的策略。

热点数据动态缓存的策略总体思路：**通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据**。

以电商平台场景中的例子，现在要求只缓存用户经常访问的 Top 1000 的商品。具体细节如下：

- 先通过缓存系统做一个排序队列（比如存放 1000 个商品），系统会根据商品的访问时间，更新队列信息，越是最近访问的商品排名越靠前；
- 同时系统会定期过滤掉队列中排名最后的 200 个商品，然后再从数据库中随机读取出 200 个商品加入队列中；
- 这样当请求每次到达的时候，会先从队列中获取商品 ID，如果命中，就根据 ID 再从另一个缓存数据结构中读取实际的商品信息，并返回。

在 Redis 中可以用 zadd 方法和 zrange 方法来完成排序队列和获取 200 个商品的操作



**2.怎么处理redis 和 数据库 一致问题**

https://xiaolincoding.com/redis/architecture/mysql_redis_consistency.html



**3.Redis 主从复制**

https://xiaolincoding.com/redis/cluster/master_slave_replication.html



**5.0 零拷贝技术**

提高文件传输性能

不用在内存层面去拷贝数据，所有数据都是通过DMA进行传输

零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，**只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运**

![操作系统01](D:\02实习\02Notes\InterviewNotes\笔记图片\操作系统01.png)





**5.非阻塞IO**





**6.0socket**

要想客户端和服务器能在网络中通信，那必须得使用 Socket 编程，它是进程间通信里比较特别的方式，特别之处在于它是可以跨主机间通信

监听的 Socket 和真正用来传数据的 Socket 是两个：

- 一个叫作**监听 Socket**；
- 一个叫作**已连接 Socket**

![操作系统02](D:\02实习\02Notes\InterviewNotes\笔记图片\操作系统02.png)



**服务器单机理论最大能连接多少个客户端**

- TCP 连接是由四元组唯一确认的，这个四元组就是：本机IP, 本机端口, 对端IP, 对端端口

- 服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以**最大 TCP 连接数 = 客户端 IP 数×客户端端口数**   

- 对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是**服务端单机最大 TCP 连接数约为 2 的 48 次方**

**实际受到限制**

- **文件描述符**，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024
- **系统内存**，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的





**6.IO多路复用**

- **多进程模型** 

  基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，为每个客户端分配一个进程来处理请求

  当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣

- **多线程模型**

  既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求

  使用**线程池**的方式来避免线程的频繁创建和销毁

  ![操作系统03](D:\02实习\02Notes\InterviewNotes\笔记图片\操作系统03.png)

-  **I/O 多路复用**

  只使用一个进程来维护多个 Socket ，可以只在一个进程里处理多个文件的 I/O

  处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用;  很类似一个 CPU 并发多个进程，所以也叫做时分多路复用

  select/poll/epoll 内核提供给用户态的多路复用系统调用

  - select ：已连接的 Socket 都放到一个**文件描述符集合**，然后调用 select 函数将文件描述符集合**拷贝**到内核里，让内核来检查是否有网络事件产生，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合**拷贝**回用户态里，然后用户态还需要再通过**遍历**的方法找到可读或可写的 Socket，然后再对其处理

    使用固定长度的 BitsMap，表示文件描述符集合，只能监听 0~1023 的文件描述符

  - poll ：和 select 并没有太大的本质区别，都是使用「线性结构」存储进程关注的 Socket 集合； 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制

  - epoll 

    epoll 在内核里使用**红黑树来跟踪进程所有待检测的文件描述字** ， 可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配

     epoll 使用**事件驱动**的机制，内核里**维护了一个链表来记录就绪事件**

![操作系统05](D:\02实习\02Notes\InterviewNotes\笔记图片\操作系统05.png)

epoll 的方式即使监听的 Socket 数量越多的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常的多了，上限就为系统定义的进程打开的最大文件描述符个数； 因而，**epoll 被称为解决 C10K 问题的利器**

使用 I/O 多路复用时，**最好搭配非阻塞 I/O 一起使用**





**6.1非阻塞IO**

当调用任何一个function的时候, 都能立刻得到一个返回值. 这个程序里的所有function都是即时执行完毕, 非阻塞的， **好处**是你可以预期到每一行代码都能马上执行完毕, 并且执行下一行代码



但有时候我们又必须等待一些事件的完成, 比如等待鼠标点击响应, 等待网络socket接受到足够的数据



**7.linux 命令**

**查询文本里面有多少个单词**

**wc -w install.log **

~~~shell
# 可以计算文件中 字节数、字数、行数
wc testfile           # testfile文件的统计信息  
3 92 598 testfile       # testfile文件的行数为3、单词数92、字节数598 

wc -c或--bytes或--chars 只显示 字节数
	-l或--lines 显示行数
	-w或--words 只显示字数 单词数
~~~



**查看go进程号**

~~~shell
#ps 显示当前进程的状态，类似于 windows 的任务管理器
ps -aux
	ps -aux | grep root(进程关键字)

# 查看进程，获取进程号
lsof -i:8000(端口号) 

#netstat
netstat -ntlp | grep port

#当不知道端口号，但是知道程序名称时，使用ps aux查看
ps -aux | grep server.py

~~~





**基本命令**

~~~shell
cat # 查看文件命令
	cat xxx | grep word # 搜索xxx文件中 匹配word的结果
more # 分页查看文件命令
less # 分页查看文件 可以向前向后看
	less -mN xxx # 如此可分页并显示行号 并显示百分比
tail -n # 查看文件后面 n行
grep 正则表达式 # 用于字符串搜索 模糊查询
ps # 查看系统进程
	ps -aux|grep redis BSD格式查看进程名称带有redis的系统进程（常用技巧）

~~~





**8. 硬链接 软连接**

硬链接

- 命令  ln
- 可以认为是一个指针， 指向文件索引节点的指针， 系统并不为它重新分配 inode ；每添加一个一个硬链接，文件的链接 数就加 1
- 不可以在不同文件系统的文件间建立链接
- 只有超级用户才可以为目录创建硬链接



软连接

- ln -s
- 没有任何文件系统的限制，任何用户可以创建指向目录的符 号链接， 应用广泛
- 因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录 中，再访问链接文件，系统就找不到了
- 要系统分配额外的空间用于建立新的索引节点和保存原文件的路径

